--- a/fs/smb/server/transport_tcp.c
+++ b/fs/smb/server/transport_tcp.c
@@ -87,14 +87,6 @@ static struct tcp_transport *alloc_trans
 		return NULL;
 	}
 
-#if IS_ENABLED(CONFIG_IPV6)
-	if (client_sk->sk->sk_family == AF_INET6)
-		memcpy(&conn->inet6_addr, &client_sk->sk->sk_v6_daddr, 16);
-	else
-		conn->inet_addr = inet_sk(client_sk->sk)->inet_daddr;
-#else
-	conn->inet_addr = inet_sk(client_sk->sk)->inet_daddr;
-#endif
 	conn->transport = KSMBD_TRANS(t);
 	KSMBD_TRANS(t)->conn = conn;
 	KSMBD_TRANS(t)->ops = &ksmbd_tcp_transport_ops;
@@ -238,7 +230,6 @@ static int ksmbd_kthread_fn(void *p)
 {
 	struct socket *client_sk = NULL;
 	struct interface *iface = (struct interface *)p;
-	struct ksmbd_conn *conn;
 	int ret;
 
 	while (!kthread_should_stop()) {
@@ -257,34 +248,6 @@ static int ksmbd_kthread_fn(void *p)
 			continue;
 		}
 
-		/*
-		 * Limits repeated connections from clients with the same IP.
-		 */
-		down_read(&conn_list_lock);
-		list_for_each_entry(conn, &conn_list, conns_list)
-#if IS_ENABLED(CONFIG_IPV6)
-			if (client_sk->sk->sk_family == AF_INET6) {
-				if (memcmp(&client_sk->sk->sk_v6_daddr,
-					   &conn->inet6_addr, 16) == 0) {
-					ret = -EAGAIN;
-					break;
-				}
-			} else if (inet_sk(client_sk->sk)->inet_daddr ==
-				 conn->inet_addr) {
-				ret = -EAGAIN;
-				break;
-			}
-#else
-			if (inet_sk(client_sk->sk)->inet_daddr ==
-			    conn->inet_addr) {
-				ret = -EAGAIN;
-				break;
-			}
-#endif
-		up_read(&conn_list_lock);
-		if (ret == -EAGAIN)
-			continue;
-
 		if (server_conf.max_connections &&
 		    atomic_inc_return(&active_num_conn) >= server_conf.max_connections) {
 			pr_info_ratelimited("Limit the maximum number of connections(%u)\n",
--- a/fs/smb/server/connection.h
+++ b/fs/smb/server/connection.h
@@ -46,12 +46,6 @@ struct ksmbd_conn {
 	struct mutex			srv_mutex;
 	int				status;
 	unsigned int			cli_cap;
-	union {
-		__be32			inet_addr;
-#if IS_ENABLED(CONFIG_IPV6)
-		u8			inet6_addr[16];
-#endif
-	};
 	char				*request_buf;
 	struct ksmbd_transport		*transport;
 	struct nls_table		*local_nls;
